#!/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/bash
#!/usr/bin/env bash

set -eu
set -o pipefail

# Credits to https://github.com/nix-community/home-manager/blob/master/lib/bash/home-manager.sh

# Sets up colors suitable for the `errorEcho`, `warnEcho`, and `noteEcho`
# functions.
#
# The check for terminal output and color support is heavily inspired by
# https://unix.stackexchange.com/a/10065.
#
# The setup respects the `NO_COLOR` environment variable.
function setupColors() {
    normalColor=""
    errorColor=""
    warnColor=""
    noteColor=""

    # Enable colors for terminals, and allow opting out.
    if [[ ! -v NO_COLOR && -t 1 ]]; then
        # See if it supports colors.
        local ncolors
        ncolors=$(tput colors 2> /dev/null || echo 0)

        if [[ -n "$ncolors" && "$ncolors" -ge 8 ]]; then
            normalColor="$(tput sgr0)"
            errorColor="$(tput bold)$(tput setaf 1)"
            warnColor="$(tput setaf 3)"
            noteColor="$(tput bold)$(tput setaf 6)"

            # Text attributes
            BOLD="$(tput bold)"
            # UNDERLINE="$(tput smul)"
            # BLINK="$(tput blink)"
            # REVERSE="$(tput rev)"
            NC="$(tput sgr0)"  # No Color

            # Regular colors
            # BLACK="$(tput setaf 0)"
            # RED="$(tput setaf 1)"
            GREEN="$(tput setaf 2)"
            YELLOW="$(tput setaf 3)"
            # BLUE="$(tput setaf 4)"
            # MAGENTA="$(tput setaf 5)"
            # CYAN="$(tput setaf 6)"
            # WHITE="$(tput setaf 7)"
        fi
    fi
}




setupColors

function errorEcho() {
    echo "${errorColor}$*${normalColor}"
}

function warnEcho() {
    echo "${warnColor}$*${normalColor}"
}

function noteEcho() {
    echo "${noteColor}$*${normalColor}"
}

function verboseEcho() {
    if [[ -v VERBOSE ]]; then
        echo "$*"
    fi
}

function _i() {
    local msgid="$1"
    shift

    # shellcheck disable=2059
    printf "$("$msgid")\n" "$@"
}

function _ip() {
    local msgid="$1"
    local msgidPlural="$2"
    local count="$3"
    shift 3

    # shellcheck disable=2059
    printf "$("$msgid" "$msgidPlural" "$count")\n" "$@"
}

function _iError() {
    echo -n "${errorColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iWarn() {
    echo -n "${warnColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iNote() {
    echo -n "${noteColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iVerbose() {
    if [[ -v VERBOSE ]]; then
        _i "$@"
    fi
}

# Credits: https://github.com/srid/flake-root/blob/master/flake-module.nix
# This function is used to find the flake root and set it as a env varible.
findUp() {
    ancestors=()
    while true; do
    if [[ -f $1 ]]; then
        echo "$PWD"
        exit 0
    fi
    ancestors+=("$PWD")
    if [[ $PWD == / ]] || [[ $PWD == // ]]; then
        echo "ERROR: Unable to locate the ${config.flake-root.projectRootFile} in any of: ''${ancestors[*]@Q}" >&2
        exit 1
    fi
    cd ..
    done
}

# Runs the given command on live run, otherwise prints the command to standard
# output.
function run() {

    if [[ -v DRY_RUN ]] ; then
        echo "$@"
    elif [[ -v quiet ]] ; then
        "$@" > /dev/null
    elif [[ -v silence ]] ; then
        "$@" > /dev/null 2>&1
    else
        "$@"
    fi
}

  UNAMEOUT="$(uname -s)"

# Verify operating system is supported...
case "${UNAMEOUT}" in
    Linux*)             MACHINE=linux;;
    Darwin*)            MACHINE=mac;;
    *)                  MACHINE="UNKNOWN"
esac

if [ "$MACHINE" == "UNKNOWN" ]; then
    echo "Unsupported operating system [$(uname -s)]. SnowBlower supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
fi

# These are the must have varibles for the project
export SB_FLAKE_ROOT=$(findUp 'flake.nix')
export SB_PROJECT_ROOT="$SB_FLAKE_ROOT/.snowblower"
export PROJECT_PROFILE="$SB_PROJECT_ROOT/profile"
export PROJECT_STATE="$SB_PROJECT_ROOT/state"
export PROJECT_RUNTIME="$SB_PROJECT_ROOT/runtime"

# Create directories if they don't exist
if [ ! -d "$SB_PROJECT_ROOT" ]; then
    noteEcho "Creating project directory: $SB_PROJECT_ROOT"
    mkdir -p "$SB_PROJECT_ROOT"
fi
if [ ! -d "$PROJECT_PROFILE" ]; then
    noteEcho "Creating profile directory: $PROJECT_PROFILE"
    mkdir -p "$PROJECT_PROFILE"
fi

if [ ! -d "$PROJECT_STATE" ]; then
    noteEcho "Creating state directory: $PROJECT_STATE"
    mkdir -p "$PROJECT_STATE"
fi

if [ ! -d "$PROJECT_RUNTIME" ]; then
    noteEcho "Creating runtime directory: $PROJECT_RUNTIME"
    mkdir -p "$PROJECT_RUNTIME"
fi


# Check if Docker is installed
if ! command -v docker &> /dev/null; then
    errorEcho "Docker is not installed or not in PATH. Please install Docker to continue."
    exit 1
fi

# Check if Docker Compose is available
if ! docker compose &> /dev/null && ! command -v docker-compose &> /dev/null; then
    errorEcho "Docker Compose is not installed or not in PATH. Please install Docker Compose to continue."
    exit 1
fi

# Define Docker Compose command prefix...
if docker compose &> /dev/null; then
    DOCKER_COMPOSE=(docker compose)
else
    DOCKER_COMPOSE=(docker-compose)
fi


  cd $SB_FLAKE_ROOT

  function setupEnvironmentVariables() {
  # Only source this once.
  if [ -v __SB_SESS_VARS_SOURCED ]; then return; fi
  export __SB_SESS_VARS_SOURCED=1

  
}

setupEnvironmentVariables


  # Function that prints the available commands...
function display_help {
    echo "❄️ 💨 SnowBlower"
    echo
    echo "${YELLOW}Usage:${NC}" >&2
    echo "  snow COMMAND [options] [arguments]"
    echo
    echo "${YELLOW}SnowBlower Commands:${NC}"
    echo "  ${GREEN}snow switch${NC}          TODO: Foo Bar"
    echo
    echo "${YELLOW}aider Commands:${NC}"
echo "  ${GREEN}snow aider start${NC}          start aider"




    echo
    exit 1
}





  # Proxy the "help" command...
if [ $# -gt 0 ]; then
    if [ "$1" == "help" ] || [ "$1" == "-h" ] || [ "$1" == "-help" ] || [ "$1" == "--help" ]; then
        display_help
    fi
else
    display_help
fi



