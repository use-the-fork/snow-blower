#!/usr/bin/env bash

set -eu
set -o pipefail

# Credits to https://github.com/nix-community/home-manager/blob/master/lib/bash/home-manager.sh

# Sets up colors suitable for the `errorEcho`, `warnEcho`, and `noteEcho`
# functions.
#
# The check for terminal output and color support is heavily inspired by
# https://unix.stackexchange.com/a/10065.
#
# The setup respects the `NO_COLOR` environment variable.
function setupColors() {
    normalColor=""
    errorColor=""
    warnColor=""
    noteColor=""

    # Enable colors for terminals, and allow opting out.
    if [[ ! -v NO_COLOR && -t 1 ]]; then
        # See if it supports colors.
        local ncolors
        ncolors=$(tput colors 2> /dev/null || echo 0)

        if [[ -n "$ncolors" && "$ncolors" -ge 8 ]]; then
            normalColor="$(tput sgr0)"
            errorColor="$(tput bold)$(tput setaf 1)"
            warnColor="$(tput setaf 3)"
            noteColor="$(tput bold)$(tput setaf 6)"

            # Text attributes
            BOLD="$(tput bold)"
            # UNDERLINE="$(tput smul)"
            # BLINK="$(tput blink)"
            # REVERSE="$(tput rev)"
            NC="$(tput sgr0)"  # No Color

            # Regular colors
            # BLACK="$(tput setaf 0)"
            RED="$(tput setaf 1)"
            GREEN="$(tput setaf 2)"
            YELLOW="$(tput setaf 3)"
            # BLUE="$(tput setaf 4)"
            # MAGENTA="$(tput setaf 5)"
            # CYAN="$(tput setaf 6)"
            WHITE="$(tput setaf 7)"
        fi
    fi
}




setupColors

function statusEcho() {
    local status="$1"
    local message="$2"
    local detail="${3:-}"
    
    if [ "$status" == "OK" ]; then
        echo "${WHITE}[ ${GREEN} OK ${WHITE} ]  ${NC}${message} ${WHITE}${detail}${NC}"
    else
        echo "${WHITE}[ ${RED}FAIL${WHITE} ]  ${NC}${message} ${WHITE}${detail}${NC}"
    fi
}

function errorEcho() {
    echo "${errorColor}$*${normalColor}"
}

function warnEcho() {
    echo "${warnColor}$*${normalColor}"
}

function noteEcho() {
    echo "${noteColor}$*${normalColor}"
}

function verboseEcho() {
    if [[ -v VERBOSE ]]; then
        echo "$*"
    fi
}

function _i() {
    local msgid="$1"
    shift

    # shellcheck disable=2059
    printf "$("$msgid")\n" "$@"
}

function _ip() {
    local msgid="$1"
    local msgidPlural="$2"
    local count="$3"
    shift 3

    # shellcheck disable=2059
    printf "$("$msgid" "$msgidPlural" "$count")\n" "$@"
}

function _iError() {
    echo -n "${errorColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iWarn() {
    echo -n "${warnColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iNote() {
    echo -n "${noteColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iVerbose() {
    if [[ -v VERBOSE ]]; then
        _i "$@"
    fi
}

# Credits: https://github.com/srid/flake-root/blob/master/flake-module.nix
# This function is used to find the flake root and set it as a env varible.
findUp() {
    ancestors=()
    while true; do
    if [[ -f $1 ]]; then
        echo "$PWD"
        exit 0
    fi
    ancestors+=("$PWD")
    if [[ $PWD == / ]] || [[ $PWD == // ]]; then
        echo "ERROR: Unable to locate the ${config.flake-root.projectRootFile} in any of: ''${ancestors[*]@Q}" >&2
        exit 1
    fi
    cd ..
    done
}

function __sb__createDirectory() {
    local dirPath="$1"
    # Evaluate the path with variables
    dirPath=$(eval echo "$dirPath")

    # Check if the path is not already within the project root
    if [[ "$dirPath" != "$SB_PROJECT_ROOT"* ]]; then
        dirPath="${SB_PROJECT_ROOT}/${dirPath}"
    fi

    mkdir -p "$dirPath"
    statusEcho "OK" "Created directory" "$dirPath"
}

# Runs the given command on live run, otherwise prints the command to standard
# output.
function run() {

    if [[ -v DRY_RUN ]] ; then
        echo "$@"
    elif [[ -v quiet ]] ; then
        "$@" > /dev/null
    elif [[ -v silence ]] ; then
        "$@" > /dev/null 2>&1
    else
        "$@"
    fi
}


  function __sb__createDirectories() {
  statusEcho "OK" "Creating Directories" "${SB_PROJECT_ROOT}"
  __sb__createDirectory '${SB_PROJECT_STATE}/npm'
__sb__createDirectory '${SB_PROJECT_STATE}/npm/config'

}


  UNAMEOUT="$(uname -s)"

# Verify operating system is supported...
case "${UNAMEOUT}" in
    Linux*)             MACHINE=linux;;
    Darwin*)            MACHINE=mac;;
    *)                  MACHINE="UNKNOWN"
esac

if [ "$MACHINE" == "UNKNOWN" ]; then
    echo "Unsupported operating system [$(uname -s)]. SnowBlower supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
fi


# Source the ".env" file so environment variables are available...
# shellcheck source=/dev/null
if [ -n "${APP_ENV+x}" ] && [ -n "$APP_ENV" ] && [ -f ./.env."$APP_ENV" ]; then
  source ./.env."$APP_ENV";
elif [ -f ./.env ]; then
  source ./.env;
fi


# Create a session file in tmp dir. this allows us to do the "heavy" lifiting for the snow command one time.
export SB_SESS_FILE="${TMPDIR:-/tmp}/.sb_session_$(tty | tr '/' '_')"


function __sb__bootSnowBlowerEnvironment() {
    # Only source this once.

    if [ -f "$SB_SESS_FILE" ]; then
        source "$SB_SESS_FILE"
        warnEcho ${SB_SESS_FILE}
        return
    fi

    warnEcho "Booting SnowBlower Session"
    statusEcho "OK" "Creating Session File" "${SB_SESS_FILE}"

    # Check if Docker is installed
    if ! command -v docker &> /dev/null; then
        statusEcho "FAIL" "Docker is not installed or not in PATH. Please install Docker to continue."
        exit 1
    fi

    # Check if Docker Compose is available
    if ! docker compose &> /dev/null && ! command -v docker-compose &> /dev/null; then
        statusEcho "FAIL" "Docker Compose is not installed or not in PATH. Please install Docker Compose to continue."
        exit 1
    fi

    # These are the must have varibles for the project
    export SB_FLAKE_ROOT=$(findUp 'flake.nix')
    export SB_PROJECT_ROOT="$SB_FLAKE_ROOT/.snowblower"
    export SB_PROJECT_PROFILE="$SB_PROJECT_ROOT/profile"
    export SB_PROJECT_STATE="$SB_PROJECT_ROOT/state"
    export SB_PROJECT_RUNTIME="$SB_PROJECT_ROOT/runtime"
    
    # Save exports to session file
    echo "export SB_FLAKE_ROOT=\"$SB_FLAKE_ROOT\"" > "$SB_SESS_FILE"
    echo "export SB_PROJECT_ROOT=\"$SB_PROJECT_ROOT\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_PROFILE=\"$SB_PROJECT_PROFILE\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_STATE=\"$SB_PROJECT_STATE\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_RUNTIME=\"$SB_PROJECT_RUNTIME\"" >> "$SB_SESS_FILE"
    
    statusEcho "OK" "SnowBlower directory set to" "${SB_PROJECT_ROOT}"

    # Create directories if they don't exist
    if [ ! -d "$SB_PROJECT_ROOT" ]; then
        statusEcho "OK" "Creating project directory" "${SB_PROJECT_ROOT}"
        mkdir -p "$SB_PROJECT_ROOT"
    fi
    if [ ! -d "$SB_PROJECT_PROFILE" ]; then
        statusEcho "OK" "Creating profile directory" "${SB_PROJECT_PROFILE}"
        mkdir -p "$SB_PROJECT_PROFILE"
    fi

    if [ ! -d "$SB_PROJECT_STATE" ]; then
        statusEcho "OK" "Creating state directory" "${SB_PROJECT_STATE}"
        mkdir -p "$SB_PROJECT_STATE"
    fi

    if [ ! -d "$SB_PROJECT_RUNTIME" ]; then
        statusEcho "OK" "Creating runtime directory" "${SB_PROJECT_RUNTIME}"
        mkdir -p "$SB_PROJECT_RUNTIME"
    fi

    # this function is added via a seperate package in files.nix.
    # But we need to boot it here so we can be sure all directories are created.
    __sb__createDirectories

    # Define Docker Compose command prefix
    if docker compose &> /dev/null; then
        export SB_DOCKER_COMPOSE="docker compose"
    else
        export SB_DOCKER_COMPOSE="docker-compose"
    fi

    echo "export SB_DOCKER_COMPOSE=\"$SB_DOCKER_COMPOSE\"" >> "$SB_SESS_FILE"
    statusEcho "OK" "Docker Compose Command set as" "${SB_DOCKER_COMPOSE}"

    # Check if nix command is available and set variable if found
    if [ -n "${SB_SESS_IS_DEV_SHELL+x}" ]; then
        statusEcho "OK" "Nix command found and available"
    else
        statusEcho "FAIL" "Nix command not found, some features may be limited"
    fi

    echo "export __SB_SESS_BOOTED=1" >> "$SB_SESS_FILE"

    echo
}

__sb__bootSnowBlowerEnvironment

# Finally we define environment variables...
export SB_APP_SERVICE=${SB_APP_SERVICE:-"snowblower.test"}
export APP_USER=${APP_USER:-"snowblower"}
export SB_USER_UID=${USER_UID:-$UID}
export SB_USER_GID=${USER_GID:-$(id -g)}


  function setupEnvironmentVariables() {
  # Only source this once.
  if [ -v __SB_SESS_VARS_SOURCED ]; then return; fi
  export __SB_SESS_VARS_SOURCED=1

  export NPM_CONFIG_CACHE="${SB_PROJECT_STATE}/npm"
export NPM_CONFIG_TMP="${SB_PROJECT_STATE}/npm"
export NPM_CONFIG_USERCONFIG="${SB_PROJECT_STATE}/npm/config"
}

setupEnvironmentVariables


  # Function that prints the available commands...
function display_help {
    echo "❄️ 💨 SnowBlower"
    echo "All Flake No Fluff"
    echo
    echo "${YELLOW}Usage:${NC}" >&2
    echo "  snow COMMAND [options] [arguments]"
    echo
    echo "${YELLOW}SnowBlower Commands:${NC}"
    echo "  ${GREEN}snow switch${NC}          TODO: Foo Bar"
    echo
    echo "${YELLOW}Aider Commands:${NC}"
echo "  ${GREEN}snow aider ...${NC}          Run a Aider command"
echo "  ${GREEN}snow aider start${NC}          w/ linting, watchfiles, and conventions."

echo

echo "${YELLOW}NPM Commands:${NC}"
echo "  ${GREEN}snow npm ...${NC}          Run a NPM command"


echo

echo "${YELLOW}Treefmt Commands:${NC}"
echo "  ${GREEN}snow treefmt ...${NC}          Run a Treefmt command"


echo


    echo
    exit 1
}


  # Proxy the "help" command...
if [ $# -gt 0 ]; then
    if [ "$1" == "help" ] || [ "$1" == "-h" ] || [ "$1" == "-help" ] || [ "$1" == "--help" ]; then
        display_help
    fi
else
    display_help
fi

  function __sb__command__aider {
  aider
}

function __sb__command__aider__start {
               aider --model sonnet --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --read "CONVENTIONS.MD" --lint-cmd "snow treefmt"

           }


function __sb__command__npm {
  npm
}




function __sb__command__treefmt {
  treefmt
}





# Function that outputs SnowBlower is not running...
function __sb__isNotRunning {
    echo "${BOLD}SnowBlower is not running.${NC}" >&2
    echo "" >&2
    echo "${BOLD}You may start docker using the following commands:${NC} './snow up'" >&2

    exit 1
}

# Function to run dynamically generated command functions
function __sb__runCommand {
    local command_name="$1"
    local subcommand_name="$2"
    
    # First try the specific command+subcommand function
    local specific_function="__sb__command__${command_name}__${subcommand_name}"
    
    # Then try the general command function
    local general_function="__sb__command__${command_name}"
    
    # Check if the specific function exists
    if declare -f "$specific_function" > /dev/null; then
        # Execute the specific function with remaining arguments
        shift 2
        "$specific_function" "$@"
    # Check if the general function exists
    elif declare -f "$general_function" > /dev/null; then
        # Execute the general function with all subcommands
        shift 1
        "$general_function" "$@"
    else
        errorEcho "Unknown command: snow $command_name $subcommand_name"
        errorEcho "Run 'snow help' for a list of available commands."
        exit 1
    fi
}

# TODO: This should prob be handled in the run_command function.
# Check if $2 exists before passing it to run_command                                                
if [ $# -ge 2 ]; then                                                                                
    __sb__runCommand "$1" "$2"                                                                            
else                                                                                                 
    __sb__runCommand "$1" ""                                                                              
fi 


