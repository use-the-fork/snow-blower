{
  inputs,
  flake-parts-lib,
  ...
}: {
  imports = [
    inputs.flake-parts.flakeModules.flakeModules
  ];
  flake.flakeModules.docker-compose = {
    options.perSystem = flake-parts-lib.mkPerSystemOption ({
      lib,
      pkgs,
      config,
      ...
    }: let
      inherit (lib) types mkOption;
      inherit (import ./utils.nix {inherit lib pkgs;}) serviceType;

      yamlFormat = pkgs.formats.yaml {};

      textFormat = {
        generate = _name: content: pkgs.writeText "dockerfile" content;
      };
    in {
      imports = [
        {
          options.snowblower.docker-compose.services = mkOption {
            type = types.submoduleWith {
              modules = [{freeformType = types.attrsOf serviceType;}];
              specialArgs = {inherit pkgs;};
            };
            default = {};
            description = ''
              The services that are available to docker-compose
            '';
          };
        }
      ];

      options.snowblower.docker-compose = {
        fileName = mkOption {
          type = types.str;
          default = "docker-compose.yml";
          description = ''
            The name of the docker-compose file generated by this module.
          '';
        };
        packages = mkOption {
          type = types.listOf types.package;
          description = "A list of packages to expose inside the docker developer container. See https://search.nixos.org/packages for packages.";
          default = [];
        };
      };

      config.snowblower = let
        # Extract service configurations
        composeServices =
          lib.mapAttrs (_name: service: service.outputs.service)
          config.snowblower.docker-compose.services;

        # Extract networks from services
        serviceNetworks = lib.unique (lib.flatten (
          lib.mapAttrsToList (
            _name: service:
              if service.enable && service.networks != []
              then service.networks
              else []
          )
          config.snowblower.docker-compose.services
        ));

        # Create networks configuration
        networksConfig = lib.listToAttrs (map (name: {
            inherit name;
            value = {};
          })
          serviceNetworks);

        # Create the compose configuration
        composeConfig =
          {
            services = composeServices;
          }
          // lib.optionalAttrs (serviceNetworks != []) {
            networks = networksConfig;
          };

        # Create Dockerfile content
        dockerfileContent = ''
          FROM docker.io/use-the-fork/snowblower-base:latest
          ${lib.concatMapStringsSep "\n" (pkg: "RUN nix-env -iA pkgs.${pkg.pname or pkg.name}") config.snowblower.docker-compose.packages}
        '';
      in {
        packages = [
          pkgs.docker-compose
        ];

        docker-compose.services.dev = {
          enable = true;
          service = {
            build = {
              context = ".";
              dockerfile = "./docker/Dockerfile";
              args = {
                USER_UID = "\${USER_UID}";
                USER_GID = "\${USER_GID}";
              };
            };
            environment = {
              USER_GID = "\${USER_GID}";
            };
            volumes = [
              ".:/workspace"
            ];
            working_dir = "/workspace";
            tty = true;
          };
        };

        core.files."docker-compose.yml" = {
          format = yamlFormat;
          settings = composeConfig;
        };

        core.files."docker/Dockerfile" = {
          format = textFormat;
          settings = dockerfileContent;
        };
      };
    });
  };
}
