#!/usr/bin/env bash

set -e
set -o pipefail

# Credits to https://github.com/nix-community/home-manager/blob/master/lib/bash/home-manager.sh

# Sets up colors suitable for the `errorEcho`, `warnEcho`, and `noteEcho`
# functions.
#
# The check for terminal output and color support is heavily inspired by
# https://unix.stackexchange.com/a/10065.
#
# The setup respects the `NO_COLOR` environment variable.
function setupColors() {
    normalColor=""
    errorColor=""
    warnColor=""
    noteColor=""

    # Enable colors for terminals, and allow opting out.
    if [[ ! -v NO_COLOR && -t 1 ]]; then
        # See if it supports colors.
        local ncolors
        ncolors=$(tput colors 2> /dev/null || echo 0)

        if [[ -n "$ncolors" && "$ncolors" -ge 8 ]]; then
            normalColor="$(tput sgr0)"
            errorColor="$(tput bold)$(tput setaf 1)"
            warnColor="$(tput setaf 3)"
            noteColor="$(tput bold)$(tput setaf 6)"

            # Text attributes
            BOLD="$(tput bold)"
            DIM="$(tput dim)"
            # UNDERLINE="$(tput smul)"
            # BLINK="$(tput blink)"
            # REVERSE="$(tput rev)"
            NC="$(tput sgr0)"  # No Color

            # Regular colors
            BLACK="$(tput setaf 0)"
            RED="$(tput setaf 1)"
            GREEN="$(tput setaf 2)"
            YELLOW="$(tput setaf 3)"
            BLUE="$(tput setaf 4)"
            MAGENTA="$(tput setaf 5)"
            CYAN="$(tput setaf 6)"
            WHITE="$(tput setaf 7)"
        fi
    fi
}




setupColors

function statusEcho() {
    local status="${1:-}"
    local message="$2"
    local detail="${3:-}"
    
    if [ "$status" == "OK" ]; then
        echo "${WHITE}[ ${GREEN} OK ${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    elif [ "$status" == "FAIL" ]; then
        echo "${WHITE}[ ${RED}FAIL${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    elif [ "$status" == "WARN" ]; then
        echo "${WHITE}[ ${YELLOW}WARN${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    elif [ "$status" == "INFO" ]; then
        echo "${WHITE}[ ${BLUE}INFO${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    else
        echo "          ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    fi
}

function errorEcho() {
    echo "${errorColor}$*${normalColor}"
}

function warnEcho() {
    echo "${warnColor}$*${normalColor}"
}

function noteEcho() {
    echo "${noteColor}$*${normalColor}"
}

function verboseEcho() {
    if [[ -v VERBOSE ]]; then
        echo "$*"
    fi
}

function _i() {
    local msgid="$1"
    shift

    # shellcheck disable=2059
    printf "$("$msgid")\n" "$@"
}

function _ip() {
    local msgid="$1"
    local msgidPlural="$2"
    local count="$3"
    shift 3

    # shellcheck disable=2059
    printf "$("$msgid" "$msgidPlural" "$count")\n" "$@"
}

function _iError() {
    echo -n "${errorColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iWarn() {
    echo -n "${warnColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iNote() {
    echo -n "${noteColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iVerbose() {
    if [[ -v VERBOSE ]]; then
        _i "$@"
    fi
}

# Credits: https://github.com/srid/flake-root/blob/master/flake-module.nix
# This function is used to find the flake root and set it as a env varible.
__sb__findUp() {
    ancestors=()
    while true; do
    if [[ -f $1 ]]; then
        echo "$PWD"
        exit 0
    fi
    ancestors+=("$PWD")
    if [[ $PWD == / ]] || [[ $PWD == // ]]; then
        echo "ERROR: Unable to locate the ${config.flake-root.projectRootFile} in any of: ''${ancestors[*]@Q}" >&2
        exit 1
    fi
    cd ..
    done
}

function __sb__createDirectory() {
    local dirPath="$1"
    # Evaluate the path with variables
    dirPath=$(eval echo "$dirPath")

    # Check if the path is not already within the project root
    if [[ "$dirPath" != "$SB_PROJECT_ROOT"* ]]; then
        dirPath="${SB_PROJECT_ROOT}/${dirPath}"
    fi

    mkdir -p "$dirPath"
    statusEcho "" "Created directory" "$dirPath"
}


  function __sb__createDirectories() {
  statusEcho "OK" "Creating Directories" "${SB_PROJECT_ROOT}"
  __sb__createDirectory '${SB_PROJECT_STATE}/npm'
__sb__createDirectory '${SB_PROJECT_STATE}/npm/config'

}


  UNAMEOUT="$(uname -s)"

# Verify operating system is supported...
case "${UNAMEOUT}" in
    Linux*)             MACHINE=linux;;
    Darwin*)            MACHINE=mac;;
    *)                  MACHINE="UNKNOWN"
esac

if [ "$MACHINE" == "UNKNOWN" ]; then
    echo "Unsupported operating system [$(uname -s)]. SnowBlower supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
fi


# Source the ".env" file so environment variables are available...
# shellcheck source=/dev/null
if [ -n "${APP_ENV+x}" ] && [ -n "$APP_ENV" ] && [ -f ./.env."$APP_ENV" ]; then
  source ./.env."$APP_ENV";
elif [ -f ./.env ]; then
  source ./.env;
fi

# Create a session file in tmp dir. this allows us to do the "heavy" lifiting for the snow command one time.
export SB_SESS_FILE="${TMPDIR:-/tmp}/.sb_session_$(tty | tr '/' '_')"


function __sb__bootSnowBlowerEnvironment() {
    # Only source this once.

    if [ -f "$SB_SESS_FILE" ]; then
        source "$SB_SESS_FILE"
        warnEcho ${SB_SESS_FILE}
        return
    fi

    statusEcho "" "Booting SnowBlower Session" ""
    statusEcho "OK" "Creating Session File" "${SB_SESS_FILE}"


    # Check if Docker is installed
    if [ -z "${SB_SESS_IS_DOCKER}" ] && ! command -v docker &> /dev/null; then
        statusEcho "FAIL" "Docker is not installed or not in PATH. Please install Docker to continue."
        exit 1
    fi

    # Check if Docker Compose is available
    if [ -z "${SB_SESS_IS_DOCKER}" ] && ! docker compose &> /dev/null && ! command -v docker-compose &> /dev/null; then
        statusEcho "FAIL" "Docker Compose is not installed or not in PATH. Please install Docker Compose to continue."
        exit 1
    fi

    # These are the must have varibles for the project
    export SB_FLAKE_ROOT=$(__sb__findUp 'flake.nix')
    export SB_PROJECT_ROOT="$SB_FLAKE_ROOT/.snowblower"
    export SB_PROJECT_PROFILE="$SB_PROJECT_ROOT/profile"
    export SB_PROJECT_STATE="$SB_PROJECT_ROOT/state"
    export SB_PROJECT_RUNTIME="$SB_PROJECT_ROOT/runtime"
    
    # Save exports to session file
    echo "export SB_FLAKE_ROOT=\"$SB_FLAKE_ROOT\"" > "$SB_SESS_FILE"
    echo "export SB_PROJECT_ROOT=\"$SB_PROJECT_ROOT\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_PROFILE=\"$SB_PROJECT_PROFILE\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_STATE=\"$SB_PROJECT_STATE\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_RUNTIME=\"$SB_PROJECT_RUNTIME\"" >> "$SB_SESS_FILE"
    
    statusEcho "OK" "SnowBlower directory set to" "${SB_PROJECT_ROOT}"

    # Create directories if they don't exist
    if [ ! -d "$SB_PROJECT_ROOT" ]; then
        statusEcho "OK" "Creating project directory" "${SB_PROJECT_ROOT}"
        mkdir -p "$SB_PROJECT_ROOT"
    fi
    if [ ! -d "$SB_PROJECT_PROFILE" ]; then
        statusEcho "OK" "Creating profile directory" "${SB_PROJECT_PROFILE}"
        mkdir -p "$SB_PROJECT_PROFILE"
    fi

    if [ ! -d "$SB_PROJECT_STATE" ]; then
        statusEcho "OK" "Creating state directory" "${SB_PROJECT_STATE}"
        mkdir -p "$SB_PROJECT_STATE"
    fi

    if [ ! -d "$SB_PROJECT_RUNTIME" ]; then
        statusEcho "OK" "Creating runtime directory" "${SB_PROJECT_RUNTIME}"
        mkdir -p "$SB_PROJECT_RUNTIME"
    fi

    # this function is added via a seperate package in files.nix.
    # But we need to boot it here so we can be sure all directories are created.
    __sb__createDirectories

    # Define Docker Compose command prefix
    if docker compose &> /dev/null; then
        export SB_DOCKER_COMPOSE="docker compose"
    else
        export SB_DOCKER_COMPOSE="docker-compose"
    fi

    echo "export SB_DOCKER_COMPOSE=\"$SB_DOCKER_COMPOSE\"" >> "$SB_SESS_FILE"
    statusEcho "OK" "Docker Compose Command set as" "${SB_DOCKER_COMPOSE}"

    # Check if we are running in a Nix Shell
    if [ -n "${SB_SESS_IS_NIX_SHELL+x}" ]; then
        statusEcho "OK" "Nix command found and available"
    else
        statusEcho "FAIL" "Nix command not found, some features may be limited"
    fi

    echo "export __SB_SESS_BOOTED=1" >> "$SB_SESS_FILE"

    echo
}

# Finally we define environment variables...
export SB_APP_SERVICE=${APP_SERVICE:-"snowblower-dev"}
export SB_USER_UID=${USER_UID:-$UID}
export SB_USER_GID=${USER_GID:-$(id -g)}
export SB_SKIP_CHECKS=${SKIP_CHECKS:-}
export SB_SESS_IS_NIX_SHELL=${IS_NIX_SHELL:-}

__sb__bootSnowBlowerEnvironment

# Split the SB_DOCKER_COMPOSE string into an array
read -ra SB_DOCKER_COMPOSE_COMMAND <<< "$SB_DOCKER_COMPOSE"


  function setupEnvironmentVariables() {
  # Only source this once.
  if [ -v __SB_SESS_VARS_SOURCED ]; then return; fi
  export __SB_SESS_VARS_SOURCED=1

  export NPM_CONFIG_CACHE="${SB_PROJECT_STATE}/npm"
export NPM_CONFIG_TMP="${SB_PROJECT_STATE}/npm"
export NPM_CONFIG_USERCONFIG="${SB_PROJECT_STATE}/npm/config"
}

setupEnvironmentVariables


  function display_help {
    echo "❄️ 💨 SnowBlower"
    echo "All Flake No Fluff"
    echo
    echo "${YELLOW}Usage:${NC}" >&2
    echo "  snow COMMAND [options] [arguments]"
    echo
    echo "${YELLOW}SnowBlower Commands:${NC}"
    echo "  ${GREEN}snow switch${NC}          Regenerate all config files."
    echo
    echo "${YELLOW}docker-compose Commands:${NC}"
    echo "  ${GREEN}snow up${NC}        Start the application"
    echo "  ${GREEN}snow up -d${NC}     Start the application in the background"
    echo "  ${GREEN}snow down${NC}      Stop the application"
    echo "  ${GREEN}snow restart${NC}   Restart the application"
    echo "  ${GREEN}snow build${NC}     Builds all containers in compose file"
    echo "  ${GREEN}snow ps${NC}        Display the status of all containers"
    echo
    __sb__displayResolvedCommands
    echo
    exit 1
}
  # Prints the resolved commands from the nix build.
function __sb__displayResolvedCommands {
    echo "${YELLOW}NPM Commands:${NC}"
echo "  ${GREEN}snow npm ...${NC}          Run a NPM command"


echo


echo "${YELLOW}Treefmt Commands:${NC}"
echo "  ${GREEN}snow treefmt ...${NC}          Run a Treefmt command"


echo


}


  # Proxy the "help" command...
if [ $# -gt 0 ]; then
    if [ "$1" == "help" ] || [ "$1" == "-h" ] || [ "$1" == "-help" ] || [ "$1" == "--help" ]; then
        display_help
    fi
else
    display_help
fi

  # Commands that are specific to Docker and Docker Compose.
function __sb__command__up {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" up
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" up "$@"
    fi
}

function __sb__command__stop {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" down
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" down "$@"
    fi
}

function __sb__command__restart {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" restart
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" restart "$@"
    fi
}

function __sb__command__ps {
    "${SB_DOCKER_COMPOSE_COMMAND[@]}" ps
}
function __sb__command__build {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" build
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" build "$@"
    fi
}
  function __sb__command__npm {
  __sb__RoutedCommandExecute "npm"
}




function __sb__command__npm-dev {
  __sb__RoutedCommandExecute "npm run dev"
}




function __sb__command__treefmt {
  __sb__RoutedCommandExecute "treefmt"
}





# Function that outputs SnowBlower is not running...
function __sb__isNotRunning {
    errorEcho "${BOLD}SnowBlower is not running.${NC}" >&2
    echo "" >&2
    errorEcho "${BOLD}You may start docker using the following commands:${NC} 'snow up'" >&2

    exit 1
}

# Function that checks
function __sb__runChecks {
    if [ -z "$SB_SKIP_CHECKS" ]; then
        # Ensure that Docker is running...
        if ! docker info > /dev/null 2>&1; then
            errorEcho "${BOLD}Docker is not running.${NC}" >&2
            exit 1
        fi

        # Determine if SnowBlower is currently up...
        if "${DOCKER_COMPOSE[@]}" ps "$SB_APP_SERVICE" 2>&1 | grep 'Exit\|exited'; then
            warnEcho "${BOLD}Shutting down old SnowBlower processes...${NC}" >&2

            "${DOCKER_COMPOSE[@]}" down > /dev/null 2>&1

            __sb__isNotRunning
        elif [ -z "$("${DOCKER_COMPOSE[@]}" ps -q "$SB_APP_SERVICE")" ]; then
            __sb__isNotRunning
        fi
    fi
}


# Figures out the type of envirment the command is running in and then routes approriatly.
function __sb__RoutedCommandExecute() {
    local cmd="$1"
    
    # Remove surrounding quotes if present
    cmd="${cmd//\'}"
    
    # If not in a nix shell, show error and exit
    if [ -z "$SB_SESS_IS_NIX_SHELL" ]; then
        __sb__isNotRunning
    fi

    # If in nix shell but not in docker, execute command directly
    if [ -n "$SB_SESS_IS_NIX_SHELL" ] && [ -z "$SB_SESS_IS_DOCKER" ]; then
        eval "$cmd"
        return $?
    fi

    # If in nix shell and in docker, execute via docker-compose
    __sb__runChecks
        
    ARGS=()
    ARGS+=(exec -u "$SB_USER_UID")
    [ ! -t 0 ] && ARGS+=(-T)
    ARGS+=("$SB_APP_SERVICE")

    # Execute the command with proper shell evaluation
    "${SB_DOCKER_COMPOSE_COMMAND[@]}" "${ARGS[@]}" bash -c "$cmd"
}

# Function to run dynamically generated command functions
function __sb__runCommand {
    local command_name="$1"
    local subcommand_name="$2"
    
    # First try the specific command+subcommand function
    local specific_function="__sb__command__${command_name}__${subcommand_name}"
    
    # Then try the general command function
    local general_function="__sb__command__${command_name}"
    
    # Check if the specific function exists
    if declare -f "$specific_function" > /dev/null; then
        # Execute the specific function with remaining arguments
        shift 2
        "$specific_function" "$@"
    # Check if the general function exists
    elif declare -f "$general_function" > /dev/null; then
        # Execute the general function with all subcommands
        shift 1
        "$general_function" "$@"
    else
        errorEcho "Unknown command: snow $command_name $subcommand_name"
        errorEcho "Run 'snow help' for a list of available commands."
        exit 1
    fi
}

# Check if $2 exists before passing it to run_command                                                
if [ $# -ge 2 ]; then                                                                                
    __sb__runCommand "$1" "$2"                                                                            
else                                                                                                 
    __sb__runCommand "$1" ""                                                                              
fi



